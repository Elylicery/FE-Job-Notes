<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

# clarfix

```css
.clearfix:after{
    content:'';
    display:table;
    clear:both;
}
.clearfix{
    *zoom:1;
}
```

# 双飞翼

![image-20201114203103858](file://E:/Documents/%E6%96%87%E6%A1%A3/%5Bjob%5D%E6%B1%82%E8%81%8C%E6%94%BB%E7%95%A5/img/image-20201114203103858-1607604791007.png?lastModify=1614497661)

```css
<body>
  <div id="header">this is header</div>
  <div id="container">
      <div id="center" class="column">
        <!--注意这里加了个center-wrap-->
        <div id="center-wrap">
          this is center
        </div>
      </div>
      <div id="left" class="column">this is left</div>
      <div id="right" class="column">this is right</div>
  </div>
  <div id="footer">this is footer</div>
</body>
```

```css
 <style type="text/css">
  #center{
    background-color: #ccc;
    width: 100%;
  }
  #center-wrap{
    margin: 0 150px 0 200px;
  }
  #left{
    width: 200px;
    margin-left: -100%;/*margin-left负值100%*/
    background-color: yellow;
  }
  #right{
    width: 150px;
    margin-left: -150px;/*margin-left负值自身宽度*/
    background-color: red;
  }
  </style>
```

# 手写jQuery

```js
class jQuery {
    constructor(selector) {
        const result = document.querySelectorAll(selector)
        const length = result.length
        for (let i = 0; i < length; i++) {
            this[i] = result[i]
        }
        this.length = length
        this.selector = selector
    }
    get(index) {
        return this[index]
    }
    each(fn) {
        for (let i = 0; i < this.length; i++) {
            const elem = this[i]
            fn(elem)
        }
    }
    on(type, fn) {
        return this.each(elem => {
            elem.addEventListener(type, fn, false)
        })
    }
    // 扩展很多 DOM API
}

// 插件机制
jQuery.prototype.dialog = function (info) {
    alert(info)
}

// “造轮子”（复写机制）
class myJQuery extends jQuery {
    constructor(selector) {
        super(selector)
    }
    // 扩展自己的方法
    addClass(className) {
    }
    style(data) {
    }
}

// const $p = new jQuery('p')
// $p.get(1)
// $p.each((elem) => console.log(elem.nodeName))
// $p.on('click', () => alert('clicked'))
```

# 手写Promise

```js
function myPromise(executor){
	//value记录异步任务成功的执行结果
	this.value = null;
	//reason记录异步任务失败的原因
	this.reason = null;
	//status记录当前状态，初始化是pending
	this.status = 'pending';
	//把this存下来，后面会用到
	var self = this;

	//定义resolve函数
	function resolve(value){
		//异步任务成功，把结果赋值给value
		self.value = value;
		//当前状态切换为resolved
		self.status = 'resolved';
	}
	
	//定义reject函数
	function reject(reason){
		//异步任务失败，把结果赋值给value
		self.reason = reason;
		//当前状态切换为rejected
		self.status = 'rejected';
	}
	
	//把resolve和reject能力赋予执行器
	executor(resolve,reject);
}

//then方法接受两个参数作为入参（可选）
myPromise.prototype.then = function(onResolved,onRejected){
	//注意：onResolved和onRejected必须是函数；如果不是，此处用一个透传来兜底
	if(typeof onResolved !== 'function'){
		onResolved = function(x) {return x};
	}
	if(typeof onRejected !== 'function'){
		onRejected = function(e) {throw e};
	}
	//依然是保存this
	var self = this;
	//判断是否是resolved状态
	if(self.status === 'resolved'){
		//如果是 执行对应的处理方法
		onResolved(self.value);
	}else if(self.status === 'rejected'){
		onRejected(self.reason);
	}
}


//测试自己编写的Promise
new myPromise(function(resolve,reject){
	resolve('成功啦！');
}).then(function(value){
	console.log(value);
},function(reason){
	console.log(reason);
});
```

# 手写flatern

```js
function flat(arr) {
    // 验证 arr 中，还有没有深层数组 [1, 2, [3, 4]]
    const isDeep = arr.some(item => item instanceof Array)
    if (!isDeep) {
        return arr // 已经是 flatern [1, 2, 3, 4]
    }

    const res = Array.prototype.concat.apply([], arr)
    return flat(res) // 递归
}

const res = flat( [1, 2, [3, 4, [10, 20, [100, 200]]], 5] )
console.log(res)
```

# 解析url参数

```js
function queryToObj(){
    const res = {}
    const search = location.search.substr(1)
    search.split('&').forEach(paramStr =>{
        const arr = paramsStr.split('=')
        const key = arr[0];
        const val = arr[1];
        res[key] = val;
    })
    return res;
}
```

```js
function queryToObj(){
    const res = {};
    const pList = new URLSearchParams(location.search)
    pList.forEach((val,key)=>{
        res[key] = val;
    })
    return res;
}
```

# 查找url参数

```js
// 传统方式
function query(name) {
    const search = location.search.substr(1) // 类似 array.slice(1)
    // search: 'a=10&b=20&c=30'
    const reg = new RegExp(`(^|&)${name}=([^&]*)(&|$)`, 'i')
    const res = search.match(reg)
    if (res === null) {
        return null
    }
    return res[2]
}
console.log( query('a') )//10
```

```js
// URLSearchParams
function query(name) {
    const search = location.search
    const p = new URLSearchParams(search)
    return p.get(name)
}
console.log( query('b') )//20
```

# 自定义事件

点击A之后，B和C都能感知到A被点击了，并且做出相应的行为 —— 就像这个点击事件是点在B和C上一样

```js
//1.首先创建一个‘clickA’事件，表示A被点击了
var clickAEvent = new Event('clickA');

//2.完成事件的监听和派发

//获取divB元素
const divB = document.getElementById('divB');
//divB监听clickA事件
divB.addEventListener('clickA',function(e){
  console.log('我是B，我感受到了小A');
  console.log(e.target);
})

//获取divC元素
const divC = document.getElementById('divC');
//divC监听clickA事件
divC.addEventListener('clickA',function(e){
  console.log('我是C，我感受到了小A');
  console.log(e.target);
})

//A元素的监听函数也得改造
const divA = document.getElementById('divA');
divA.addEventListener('click',function(){
  console.log('我是A');
  //使用 dispatchEvent 派发事件！！！
  divB.dispatchEvent(clickAEvent);
  divC.dispatchEvent(clickAEvent);
})
```

# 通用事件监听函数

```js
//通用的事件绑定函数
function bindEvent(elem,type,selector,fn){
  if(fn == null){//传了三个函数
    fn = selector;
    selector = null;
  }
  elem.addEventListener(type,event=>{
    const target = event.target;
    if(selector){
      //代理绑定
      if(target.matches(selector)){
        fn.call(target,event)
      }
    }else{
      //普通绑定
      fn.call(target,event)
    }
  })
}

// 普通绑定
const btn1 = document.getElementById('btn1')
bindEvent(btn1, 'click', function(event) {
  event.preventDefault()//这里不能用this是因为this必须是当前触发的元素(注意不能使用箭头函数！！那样this指的是上层作用域即window)
  alert(this.innerHTML)
})

// 代理绑定
const div3 = document.getElementById('div3')
bindEvent(div3, 'click', 'a', function(event) {
  event.preventDefault()
  alert(this.innerHTML)//this必须是当前触发的元素
})
```



# 深拷贝

```js
function deepClone(obj={}){
    if(typeof obj !== "object" || obj == null){
        return obj;
    }
    //初始化返回结果
    let result;
    if(obj instanceof Array){
        result = [];
    }else{
        result = {};
    }
    for(let k of obj){
        if(obj.hasOwnProperty(key)){
            result[key] = deepClone(obj[key]);
        }
    }
    return result;
}
```

# instance

```js
//判断A是否是B的实例
const instanceOf = (A,B) => {
    let p = A;
    while(p){
        if(p === B.prototype){
            return true;
        }
        p = p.__proto__;
    }
    return false;
};

//测试
instanceof([],Object)//true
instanceof(1,Number)//true
```

#  call/apply/bind

```javascript
//手写call
Function.prototype.myCall = function(context,...args){
    //Step1:把函数挂载到目标对象上（这里的this就是我们要改造的那个函数）
    context = (context === udefined || context === null)?window:content;
    context.func = this
    //Step2：执行函数,利用扩展运算符将数组展开
    let result = context.func(...args);
    //Step3 删除step1中挂到目标对象上的函数，
    delete context.func;
    return result;
}
```

```javascript
//手写apply
Function.prototype.myApply = function(content){
 content = (content === undefined || content === null)?window:content;
 content.fn = this;
 let result = argumnets[1]? content.fn(...arguments[1]) : content.fn();
 delete content.fn;
 return result;
} 
```

```js
//手写bind，思路:通过apply或call方法来实现
Function.prototype.myBind = function(){
    //将参数解析为数组
    const args = Array.prototype.slice.call(arguments);
    //获取this（取出数组第一项，数组剩余的就是传递的参数）
    const t = args.shift();
    const self = this //当前函数
    //返回一个函数
    return function(){
        //执行原函数。并返回结果
        return self.apply(t,args)
    }
}
```

# 节流和防抖

```js
//防抖：只调用最后一次
//fn是我们需要包装的事件回调，delay是每次推迟执行的等待时间
//防抖
function debounce(fn,delay){
    //定时器
    let timer = null;
    
    return function(){
        //保留调用时的this上下文
        let context = this;
        //保留调用时传入的参数
        let args = arguments;
        //每次事件被触发时，都会清除之前的旧定时器
        if(timer){
            clearTimeout(timer)
        }
        //设立新的定时器
        timer = setTimeout(function(){
            fn.apply(context,args);
            timer = null;
        },delay)
    }
}

//例子：用throttle来包装scroll的回调
const better_scroll = debounce(()=> console.log('触发了滚动事件'),1000);
document.addEvenetListener('scroll',better_scroll);
```

```js
//节流：第一调用后一段时间内都不触发
//fn是我们需要包装的事件回调，interval是时间间隔的阈值
function throttle(fn,interval = 100){
    //last为上一次触发回调的时间
    let last = 0;
    
    //将throttle处理结果当作函数返回
    return function(){
        //保留调用时的this上下文
        let context = this;
        //保留调用时传入的参数
        let args = arguments;
        //记录本次触发回调的时间
        let now = +new Date();
        
        //判断上次出发的时间和本次触发的时间差是否小于时间间隔
        if(now-last>=interval){
            //如果时间间隔大于我们设定的时间间隔阈值，则执行回调
            last = now;
            fn.apply(context.args);
        }
    }
}
//例子：用throttle来包装scroll的回调
const better_scroll = throttle(()=> console.log('触发了滚动事件'),1000);
document.addEvenetListener('scroll',better_scroll);
```

#  数据双向绑定

```js
//获取需要监听的对象
var inputObj = docuement.getElementById('userName');
//获取展示监听对象的输入框
//var showObj = document.getElementById('userNameTo');
//当失去焦点时进行值的获取
inputObj.addEventListener('blur',modelToView);
//定义一个没有原型链的空对象
var model = new Object(null);
//**核心数据绑定函数**
Object.defineProperty(model,'user',{
    set:function(value){
        user = value;
        //showObj.value = value;//赋值给显示输入框
    },
    get:function(){
        return user;
    }
})

//数据变化
function modelToView(){
    //改变属性值
    model['user'] = inputObj.value
}
```

# 13 获取url参数

获取 url 中的参数

1. 指定参数名称，返回该参数的值 或者 空字符串
2. 不指定参数名称，返回全部的参数对象 或者 {}
3. 如果存在多个同名参数，则返回数组

输入

```
http://www.nowcoder.com?key=1&key=2&key=3&test=4#hehe key
```

输出

```
[1, 2, 3]
```

**答案1 使用正则**

```js
function getUrlParam(sUrl,sKey){
	var result = {};
	sUrl.replace(/\??(\w+)=(\w+)&?/g,function(a,k,v){
		if(result[k] !== void 0){
			var t = result[k];
			result[k] = [].concat(t,v);
		}else{
			result[k] = v;
		}
	});
	if(sKey === void 0){
		return result;
	}else{
		return result[sKey] || '';
	}
}

var res = getUrlParam("http://www.nowcoder.com?key=1&key=2&key=3&test=4#hehe","key");
console.log(res);
```

1. replace()的第一个参数是一个正则表达式，第二个参数是一个回调函数，每匹配到一个符合正则表达式的结果就回调一次。参数a代表该次匹配到的字符串，k代表该次匹配到的字符串中符合第一个分组的部分，v代表该次匹配到的字符串中符合第二个分组的部分
2. 当concat()的参数是具体的值时，意味着将参数连接到调用concat()方法的数组上。result原本是一个空的对象，当回调函数第一次执行时，向该对象添加了一个key-value对，但此时的value是一个字符串"1"。因此，在回调函数第二次执行时，要向一个空数组添加字符串"1"和"2"，这也是为什么要用[].concat(k,v)。
3. 正则表达式的开头的\?是不能省略的，否则.com?key=1匹配不到。

**答案2 我的代码**

利用string的substr和indexof切割字符串的思路

```js
function getUrlParam(sUrl, sKey) {
  var start = sUrl.indexOf("?");
  var end = sUrl.indexOf("#") || sUrl.length-1;
  var subUrl = sUrl.slice(start+1,end);
  //console.log(subUrl);
  
  var keysArr = subUrl.split("&");
  var map = {};
  keysArr.forEach(item => {
    let [key,value=''] = item.split('=');
    let hasMapKey = Reflect.has(map,key)
    if(hasMapKey){
        map[key].push(value)
    }else{
        map[key] = [value]
    }
  });

  //未指定key
  if(sKey === undefined || sKey === ""){
    return map;
  }

  let res = map[sKey] || [''];
  return res.length === 1 ?res[0]:res;
}
```

# 14 dom节点查找

（完全不会）

题目：查找两个节点的最近的一个共同父节点，可以包括节点自身

输入描述:

```
oNode1 和 oNode2 在同一文档中，且不会为相同的节点
```

**思路**

js中的 contains方法，用于判断某个节点是不是另一个节点的后代

**代码1**

不用去递归也不用管谁包含谁，只要随便找一个节点，直到某个祖先节点（或自己）包含另一个节点就行了。
oNode.contains(oNode)是等于true的

```js
function commonParentNode(oNode1, oNode2) {
  for(;oNode1;oNode1=oNode1.parentNode){
    if(oNode1.contains(oNode2)){
      return oNode1;
    }
  }
}
```

**代码2 递归查找**

验证一个节点是否包含另一个节点就好了吧，不必验证两次，反正如果是被包含的关系，往上爬的时候会遇到另一个节点的。

```js
function commonParentNode(oNode1, oNode2) {
  if(oNode1.contains(oNode2)){
    return oNode1;
  }else{
    return commonParentNode(oNode1.parentNode,oNode2)
  }
}
```

# 17 时间格式化输出

按所给的时间格式输出指定的时间

格式说明
对于 2014.09.05 13:14:20

* yyyy: 年份，2014  yy: 年份，14
* MM: 月份，补满两位，09  M: 月份, 9
* dd: 日期，补满两位，05 d: 日期, 5
* HH: 24制小时，补满两位，13  H: 24制小时，13
* hh: 12制小时，补满两位，01 h: 12制小时，1
* mm: 分钟，补满两位，14 m: 分钟，14
* ss: 秒，补满两位，20 s: 秒，20
* w: 星期，为 ['日', '一', '二', '三', '四', '五', '六'] 中的某一个，本 demo 结果为 五

输入

```
formatDate(new Date(1409894060000), 'yyyy-MM-dd HH:mm:ss 星期w')
```

输出

```
2014-09-05 13:14:20 星期五
```

```js
function formatDate(t,str){
  var obj = {
    yyyy:t.getFullYear(),
    yy:(""+ t.getFullYear()).slice(-2),
    M:t.getMonth()+1,
    MM:("0"+ (t.getMonth()+1)).slice(-2),
    d:t.getDate(),
    dd:("0" + t.getDate()).slice(-2),
    H:t.getHours(),
    HH:("0" + t.getHours()).slice(-2),
    h:t.getHours() % 12,
    hh:("0"+t.getHours() % 12).slice(-2),
    m:t.getMinutes(),
    mm:("0" + t.getMinutes()).slice(-2),
    s:t.getSeconds(),
    ss:("0" + t.getSeconds()).slice(-2),
    w:['日', '一', '二', '三', '四', '五', '六'][t.getDay()]
  };
  return str.replace(/([a-z]+)/ig,function($1){return obj[$1]})
}

let res = formatDate(new Date(1409894060000), 'yyyy-MM-dd HH:mm:ss 星期w');
console.log(res);
```

备注

* $1, $2, ... $99 表示字符串中与regexp中的第1到第99个子表达式相匹配的文本
* `+`表示匹配元字符1次或多次
* `i` 忽略大小写

# 统计词频

```js
function count(str) {
  //去除空白字符处理
  str = str.replace(/\s*/g,'');
  //统计词频
  let arr = [...str];
  let res = arr.reduce(function(prev,cur){
    prev[cur] ? prev[cur]++ : prev[cur]=1;
    return prev;
  },{})
  return res;
}
var result = count('hello world');
console.log(result);//{ h: 1, e: 1, l: 3, o: 2, w: 1, r: 1, d: 1 }
```

# 去除字符串首尾的空白字符

多个简单正则处理效果有时候可能更好

```js
var str = '  Alex   ';
var pattern = /^\s+|\s+$/g;//首匹配或尾匹配
console.log('|'+str.replace(pattern,'')+"|");//|Alex|

var str = '   AMY  ';
var pattern1= /^\s+/;//首匹配
var pattern2 = /\s+$/;//尾匹配
console.log('|'+str.replace(pattern1,'').replace(pattern2,'')+"|");//|AMY|
```

封装字符串两边空白字符的一个方法，一个常用的工具函数！

```js
function trim(str){
  return str.replace(/^\s+/,'').replace(/\s+$/,'');
}

console.log(trim(" Lucy  "));
```

【补充】：去除字符串中间的所有空白字符

```js
str = str.replace(/\s*/g,'');
```



# 转驼峰

* `css：background-color:red`
* ``js: elem.style.backgroundColor = 'red';`
* jquery:`$(elem).css('background-color','red')`

总结一个工具函数

```js
/*分割转驼峰*/
var str = 'background-color';
var pattern = /-([a-z])/gi;
console.log(str.replace(pattern,function(all,letter){
  return letter.toUpperCase();//backgroundColor
}));


function toCamelCase(str){
  return str.replace(pattern,function(all,letter){
    return letter.toUpperCase();
  })
}
/*驼峰转分割*/
"backColor".replace(/[A-Z]g/,'$1'.toLowerCase())
//"backColor"
```

# 匹配HTML标签

```js
var str = '<p class="odd" id="odd">123</p>';
var pattern = /<\/?[a-zA-Z]+(\s+[a-zA-Z]+=".*")*>/g;
console.log(str.match(pattern));//[ '<p class="odd" id="odd">', '</p>' ]

var pattern2 = /<[^>]+>/g;
console.log(str.match(pattern2));//[ '<p class="odd" id="odd">', '</p>' ]

//一个例外
var strEx = '<input type="text" value=">" name="username"/>';
console.log(strEx.match(pattern));//[ '<input type="text" value=">' ]
var patternCommon =/<(?:[^"'>]|"[^"]*"|'[^']*')*>/g;
var patternCommon2 = /<(?:[^"'>]|(["'])[^"']*\1)*>/g;
console.log(strEx.match(patternCommon));//[ '<input type="text" value=">" name="username"/>' ]
```

# 9.1 字符替换

![image-20201216113845767](前端手写代码.assets/image-20201216113845767.png)



```js
function filterSensitiveWord(input){
  var sensitive = input[input.length-1];
  var output = input[0];
  for(var j=0;j<sensitive.length;j++){
    //var pattern = new RegExp(sensitive[j],"g");
    var pattern = new RegExp(`${sensitive[j]}`,"g");
    output = output.replace(pattern,'*'.repeat(sensitive[j].length));
  }
  return output;
}

var input = ['想要轻生,have sex,sexy babe',['轻生','sex']];
console.log(filterSensitiveWord(input));
```

# 9.2 收集单词并反转



![image-20201216113942398](前端手写代码.assets/image-20201216113942398.png)

```js
function reverseStr(str){
  var pattern = /[^\s]+/g;//匹配单词
  str = str.match(pattern);
  console.log(str);
  str = str.reverse();
  console.log(str);
  return str.join(' '); 
}

var res = reverseStr('the	sky	is												blue!');
console.log(res);
```



